# failirc, a fail IRC server.
#
# Copyleft meh. [http://meh.doesntexist.org | meh.ffff@gmail.com]
#
# This file is part of failirc.
#
# failirc is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# failirc is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with failirc. If not, see <http://www.gnu.org/licenses/>.

require 'thread'
require 'socket'
require 'resolv'
require 'openssl'

require 'rexml/document'
include REXML

require 'failirc'
require 'failirc/extensions'
require 'failirc/server/clients'
require 'failirc/server/links'
require 'failirc/server/channels'
require 'failirc/utils'
require 'failirc/server/errors'
require 'failirc/server/responses'
require 'failirc/server/dispatcher'

module IRC

class Server
    include Utils

    class Connections < ThreadSafeHash
        attr_reader :server

        def initialize (server)
            @server = server

            super()

            self[:listening] = {
                :sockets   => [],
                :listens   => {},
                :contextes => {},
            }

            self[:sockets] = []
            self[:things]  = {}
            self[:clients] = CaseInsensitiveHash.new
            self[:links]   = CaseInsensitiveHash.new
        end

        def empty?
            self[:sockets].empty?
        end

        def exists? (socket)
            self[:things][socket] ? true : false
        end

        alias __delete delete

        def delete (socket)
            thing = self[:things][socket]

            if thing.is_a?(Client)
                self[:clients].delete(thing.nick)
                self[:clients].delete(socket)
            elsif thing.is_a?(Link)
                self[:links].delete(thing.host)
                self[:links].delete(socket)
            end

            self[:sockets].delete(socket)
            self[:things].delete(socket)

            socket.close rescue IOError
        end
    end

    module SSLUtils
        def self.selfSignedCertificate (bits, comment)
            rsa = OpenSSL::PKey::RSA.new(bits)
  
            cert            = OpenSSL::X509::Certificate.new
            cert.version    = 3
            cert.serial     = 0
            name            = OpenSSL::X509::Name.new
            cert.subject    = name
            cert.issuer     = name
            cert.not_before = Time.now
            cert.not_after  = Time.now + (365*24*60*60)
            cert.public_key = rsa.public_key
      
            ef                    = OpenSSL::X509::ExtensionFactory.new(nil, cert)
            ef.issuer_certificate = cert
  
            cert.extensions = [
              ef.create_extension('basicConstraints', 'CA:FALSE'),
              ef.create_extension('keyUsage', 'keyEncipherment'),
              ef.create_extension('subjectKeyIdentifier', 'hash'),
              ef.create_extension('extendedKeyUsage', 'serverAuth'),
              ef.create_extension('nsComment', comment),
            ]
  
            aki = ef.create_extension('authorityKeyIdentifier', 'keyid:always,issuer:always')
            cert.add_extension(aki)
            cert.sign(rsa, OpenSSL::Digest::SHA1.new)
      
            return [cert, rsa]
        end

        def self.context (cert, key)
            context = OpenSSL::SSL::SSLContext.new

            if !cert
                comment = 'Generated by Ruby/OpenSSL'

                cert, key = self.selfSignedCertificate(1024, comment)
            else
                cert = OpenSSL::X509::Certificate.new File.read cert
                key  = OpenSSL::PKey::RSA.new File.read key
            end

            context.cert = cert
            context.key  = key

            return context
        end
    end

    attr_reader :version, :createdOn, :verbose, :dispatcher, :modules, :channels, :connections, :config

    def initialize (conf, verbose)
        @version   = IRC::VERSION
        @createdOn = Time.now
        @verbose   = verbose ? true : false

        @dispatcher = Dispatcher.new(self)

        @modules = {}

        @connections = Connections.new(self)
        @channels    = Channels.new(self)

        self.config = conf
    end

    def clients
        @connections[:clients]
    end

    def links
        @connections[:links]
    end

    def loadModule (name, path=nil)
        begin 
            if path[0] == '/'
                $LOAD_PATH.push path
                require name
                $LOAD_PATH.pop
            else
                require "#{path}/#{name}"
            end

            begin
                klass = eval("Modules::#{name}")
            rescue
            end

            if klass
                @modules[name] = klass.new(self)
                self.debug "Loaded `#{name}`.", nil
            else
                self.debug "Failed to load `#{name}`.", nil
            end
        rescue Exception => e
            self.debug(e)
        end
    end

    def host
        @config.elements['config/server/host'].text
    end

    def ip
        begin
            return Resolv.getaddress(@config.elements['config/server/host'].text)
        rescue
            return @connections[:listening][:sockets].first.addr.pop
        end
    end

    def start
        if @started
            return
        end

        if !@config
            raise '@config is missing.'
        end

        begin
            @config.elements.each('config/server/listen') {|listen|
                server  = TCPServer.new(listen.attributes['bind'], listen.attributes['port'])
                context = nil

                if listen.attributes['ssl'] == 'enabled'
                    context = SSLUtils::context(listen.attributes['sslCert'], listen.attributes['sslKey'])
                end

                @connections[:listening][:sockets].push(server)
                @connections[:listening][:listens][server]   = listen
                @connections[:listening][:contextes][server] = context
            }
        rescue Exception => e
            self.debug(e)
        end

        @listeningThreads = []
        
        @connections[:listening][:sockets].each {|socket|
            @listeningThreads.push Thread.new {
                server = socket

                begin
                    while true
                        socket, = server.accept

                        if socket
                            run socket, @connections[:listening][:listens][server], @connections[:listening][:contextes][server]
                        end
                    end
                rescue Exception => e
                    self.debug e
                end
            }
        }

        @started = true

        @dispatcher.loop()
    end

    def stop
        @stopping = true

        begin
            if @started
                @listeningThreads.each {|thread|
                    Thread.kill(thread)
                }

                @modules.each {|mod|
                    mod.finalize
                }

                @connections[:listening][:sockets].each {|server|
                    server[:socket].close
                }

                @clients.each {|key, client|
                    kill client, 'Good night sweet prince.'
                }

                @links.each {|key, link|
                    kill client, 'Good night sweet prince.'
                }
            end
        ensure
            Process.exit!(0)
        end
    end

    def stopping?
        @stopping
    end

    # Executed with each incoming connection
    def run (socket, listen, context=nil)
        # here, somehow we should check if the incoming peer is a linked server or a real client

        Thread.new {
            begin
                if listen.attributes['ssl'] == 'enabled'
                    socket = OpenSSL::SSL::SSLSocket.new socket, context
                    socket.accept
                end

                @connections[:sockets].push(socket)
                @connections[:things][socket]  = @connections[:clients][socket] = IRC::Client.new(self, socket, listen)
            rescue Exception => e
                socket.close
                self.debug(e)
            end
        }
    end

    # kill connection with harpoons on fire
    def kill (thing, message=nil)
        if !thing || thing.modes[:killing] || !@connections.exists?(thing.socket)
            return
        end

        if thing.is_a?(User)
            thing = thing.client
        end

        thing.modes[:killing] = true

        @dispatcher.execute(:kill, thing, message)

        if thing.is_a?(Client)
            thing.modes[:quitting] = true

            if thing.modes[:registered]
                @channels.each_value {|channel|
                    channel.users.delete(thing.nick)
                }
            end
        elsif thing.is_a?(Link)
            # wat
        end

        @connections.delete(thing.socket)
    end

    # reload the config and modules' configurations
    def rehash
        self.config = @configReference
    end

    def config= (reference)
        @config          = Document.new reference
        @configReference = reference

        if !@config.elements['config/server']
            @config.element['config'].add(Element.new('server'))
        end

        if !@config.elements['config/server/name']
            @config.elements['config/server'].add(Element.new('name'))
            @config.elements['config/server/name'].text = "Fail IRC"
        end

        if !@config.elements['config/server/host']
            @config.elements['config/server'].add(Element.new('host'))
            @config.elements['config/server/host'].text = Socket.gethostname
        end

        if !@config.elements['config/server/pingTimeout']
            @config.elements['config/server'].add(Element.new('pingTimeout'))
            @config.elements['config/server/pingTimeout'].text = '60'
        end

        if !@config.elements['config/server/listen']
            @config.elements['config/server'].add(Element.new('listen'))
        end

        @config.elements.each('config/server/listen') {|element|
            if !element.attributes['port']
                element.attributes['port'] = '6667'
            end

            if !element.attributes['bind']
                element.attributes['bind'] = '0.0.0.0'
            end

            if !element.attributes['ssl'] || (element.attributes['ssl'] != 'enabled' && element.attributes['ssl'] != 'disabled')
                element.attributes['ssl'] = 'disabled'
            end
        }

        if !@config.elements['config/messages']
            @config.elements['config'].add(Element.new('messages'))
        end

        if !@config.elements['config/messages/quit']
            @config.elements['config/messages'].add(Element.new('quit'))
            @config.elements['config/messages/quit'].text = 'Quit: '
        end

        if !@config.elements['config/modules']
            @config.elements['config'].add(Element.new('modules'))
        end

        @modules.each_value {|mod|
            mod.rehash
        }

        self.debug 'Loading modules.', nil

        @config.elements.each('config/modules/module') {|element|
            if !element.attributes['path']
                element.attributes['path'] = 'failirc/server/modules'
            end

            if !@modules[element.attributes['name']]
                self.loadModule(element.attributes['name'], element.attributes['path'])
            end
        }

        self.debug 'Finished loading modules.'
    end

    alias to_s host
end

end
